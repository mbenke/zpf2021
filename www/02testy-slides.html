<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Marcin Benke" />
  <title>Advanced Functional Programming</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" type="text/css" media="screen, projection, print"
    href="http://www.w3.org/Talks/Tools/Slidy2/styles/slidy.css" />
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <script src="http://www.w3.org/Talks/Tools/Slidy2/scripts/slidy.js"
    charset="utf-8" type="text/javascript"></script>
</head>
<body>
<div class="slide titlepage">
  <h1 class="title">Advanced Functional Programming</h1>
  <p class="subtitle">Testing</p>
  <p class="author">
Marcin Benke
  </p>
  <p class="date">Mar 16, 2021</p>
</div>
<div class="slide section level1">

<p><meta name="duration" content="80" /></p>
</div>
<div id="testing-haskell-programs" class="slide section level1">
<h1>Testing Haskell Programs</h1>
<ul>
<li>doctest <a href="https://github.com/sol/doctest">github: sol/doctest</a></li>
<li>HUnit</li>
<li>Quickcheck</li>
<li>QuickCheck + doctest <!-- * Hedgehog [github: hedgehogqa/haskell-hedgehog](https://github.com/hedgehogqa/haskell-hedgehog)
--></li>
</ul>
</div>
<div id="doctest" class="slide section level1">
<h1>doctest</h1>
<p>Examples in the docs can be used as regression tests</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">DoctestExamples</span> <span class="kw">where</span>
<span class="co">-- | Expect success</span>
<span class="co">-- &gt;&gt;&gt; 2 + 2</span>
<span class="co">-- 4</span>

<span class="co">-- | Expect failure</span>
<span class="co">-- &gt;&gt;&gt; 2 + 2</span>
<span class="co">-- 5</span></code></pre></div>
<pre><code>$ stack install doctest
$ stack exec doctest DoctestExamples.hs
### Failure in DoctestExamples.hs:7: expression `2 + 2&#39;
expected: 5
 but got: 4
Examples: 2  Tried: 2  Errors: 0  Failures: 1</code></pre>
</div>
<div id="an-example-from-bnfc" class="slide section level1">
<h1>An Example from BNFC</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | Generate a name in the given case style taking into account the reserved</span>
<span class="co">-- word of the language.</span>
<span class="co">-- &gt;&gt;&gt; mkName [] SnakeCase &quot;FooBAR&quot;</span>
<span class="co">-- &quot;foo_bar&quot;</span>
<span class="co">-- &gt;&gt;&gt; mkName [] CamelCase &quot;FooBAR&quot;</span>
<span class="co">-- &quot;FooBAR&quot;</span>
<span class="co">-- &gt;&gt;&gt; mkName [] CamelCase &quot;Foo_bar&quot;</span>
<span class="co">-- &quot;FooBar&quot;</span>
<span class="co">-- &gt;&gt;&gt; mkName [&quot;foobar&quot;] LowerCase &quot;FooBAR&quot;</span>
<span class="co">-- &quot;foobar_&quot;</span>
<span class="ot">mkName ::</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">NameStyle</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
mkName reserved style s <span class="fu">=</span> <span class="fu">...</span></code></pre></div>
</div>
<div id="digression---haddock" class="slide section level1">
<h1>Digression - Haddock</h1>
<p>Haddock (<a href="http://haskell.org/haddock" class="uri">http://haskell.org/haddock</a>) is a commonly used Haskell documentation tool.</p>
<p>The sequence <code>{-|</code> or <code>-- |</code> (space is important) starts a comment block, which is passed to documentation</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- |The &#39;square&#39; function squares an integer.</span>
<span class="co">-- It takes one argument, of type &#39;Int&#39;.</span>
<span class="ot">square ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
square x <span class="fu">=</span> x <span class="fu">*</span> x</code></pre></div>
<pre><code>$ haddock --html Square.hs</code></pre>
</div>
<div id="hunit" class="slide section level1">
<h1>HUnit</h1>
<p>Unit tests are a common practice in many languages</p>
<p>We can do that in Haskell as well, e.g.:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Test.HUnit</span>
<span class="kw">import </span><span class="dt">MyArray</span>

main <span class="fu">=</span> runTestTT tests

tests <span class="fu">=</span> <span class="dt">TestList</span> [test1,test2]

listArray1 es <span class="fu">=</span> listArray (<span class="dv">1</span>,length es) es
test1 <span class="fu">=</span> <span class="dt">TestCase</span><span class="fu">$</span>assertEqual <span class="st">&quot;a!2 = 2&quot;</span> (listArray1 [<span class="dv">1</span><span class="fu">..</span><span class="dv">3</span>] <span class="fu">!</span> <span class="dv">2</span>) <span class="dv">2</span>
test2 <span class="fu">=</span> <span class="dt">TestCase</span><span class="fu">$</span>assertEqual <span class="st">&quot;elems . array = id&quot;</span>
                             (elems <span class="fu">$</span> listArray1 [<span class="dv">1</span><span class="fu">..</span><span class="dv">3</span>]) [<span class="dv">1</span><span class="fu">..</span><span class="dv">3</span>]</code></pre></div>
<pre><code>&gt; main
Cases: 2  Tried: 2  Errors: 0  Failures: 0
Counts {cases = 2, tried = 2, errors = 0, failures = 0}</code></pre>
</div>
<div id="lets-sort-a-list" class="slide section level1">
<h1>Let's sort a list</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mergeSort ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
mergeSort pred <span class="fu">=</span> go
  <span class="kw">where</span>
    go []  <span class="fu">=</span> []
    go [x] <span class="fu">=</span> [x]
    go xs  <span class="fu">=</span> merge (go xs1) (go xs2)
      <span class="kw">where</span> (xs1,xs2) <span class="fu">=</span> split xs

    merge xs [] <span class="fu">=</span> xs
    merge [] ys <span class="fu">=</span> ys
    merge (x<span class="fu">:</span>xs) (y<span class="fu">:</span>ys)
      <span class="fu">|</span> pred x y  <span class="fu">=</span> x <span class="fu">:</span> merge xs (y<span class="fu">:</span>ys)
      <span class="fu">|</span> otherwise <span class="fu">=</span> y <span class="fu">:</span> merge (x<span class="fu">:</span>xs) ys

    split []       <span class="fu">=</span> ([],[])
    split [x]      <span class="fu">=</span> ([x],[])
    split (x<span class="fu">:</span>y<span class="fu">:</span>zs) <span class="fu">=</span> (x<span class="fu">:</span>xs,y<span class="fu">:</span>ys)
      <span class="kw">where</span> (xs,ys) <span class="fu">=</span> split zs</code></pre></div>
</div>
<div id="sorting-unit-tests" class="slide section level1">
<h1>Sorting: unit tests</h1>
<pre><code>sort = mergeSort ((&lt;=) :: Int -&gt; Int -&gt; Bool)

sort [1,2,3,4] == [1,2,3,4]
sort [4,3,2,1] == [1,2,3,4]
sort [1,4,2,3] == [1,2,3,4]
...</code></pre>
<p>It starts getting boring...</p>
<p>...but, thanks to types, we can do better</p>
</div>
<div id="properties" class="slide section level1">
<h1>Properties</h1>
<p>An obvious sorting property:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">prop_idempotent <span class="fu">=</span> sort <span class="fu">.</span> sort <span class="fu">==</span> sort</code></pre></div>
<p>is not definable; we cannot compare functions.</p>
<p>We can &quot;cheat&quot;:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">prop_idempotent xs <span class="fu">=</span>
    sort (sort xs) <span class="fu">==</span> sort xs</code></pre></div>
<p>Let's try it in REPL:</p>
<pre><code>*Main&gt; prop_idempotent [3,2,1]
True</code></pre>
</div>
<div id="an-automation-attempt" class="slide section level1">
<h1>An automation attempt</h1>
<p>We can try to automate it:</p>
<pre><code>prop_permute :: ([a] -&gt; Bool) -&gt; [a] -&gt; Bool
prop_permute prop = all prop . permutations

*Main&gt; prop_permute prop_idempotent [1,2,3]
True
*Main&gt; prop_permute prop_idempotent [1..4]
True
*Main&gt; prop_permute prop_idempotent [1..5]
True
*Main&gt; prop_permute prop_idempotent [1..10]
  C-c C-cInterrupted.</code></pre>
</div>
<div id="quickcheck" class="slide section level1">
<h1>QuickCheck</h1>
<ul>
<li><p>Generating many unit tests is boring</p></li>
<li><p>Checking all possibilities is not realistic (except for small data - see SmallCheck)</p></li>
<li><p>Idea: generate an appropriate random sample of the data</p></li>
</ul>
<pre><code>*Main&gt; import Test.QuickCheck
*Main Test.QuickCheck&gt; quickCheck prop_idempotent
+++ OK, passed 100 tests.</code></pre>
<p>QuickCheck generated 100 random lists and checked the property</p>
<p>Of course we can wish for 1000 instead of 100:</p>
<pre><code>*Main Test.QuickCheck&gt; quickCheckWith stdArgs {maxSuccess = 1000}  prop_idempotent
+++ OK, passed 1000 tests.</code></pre>
<p>NB: we cannot generate random &quot;polymorphic values&quot;, hence <code>prop_idempotent</code> is monomorphic.</p>
<p><strong>Exercise:</strong> write and run a few tests for sorting and your own functions.</p>
</div>
<div id="how-does-it-work" class="slide section level1">
<h1>How does it work?</h1>
<p>For simplicity, let's look at QC v1</p>
<p>Main ingredients:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">quickCheck  ::</span> <span class="dt">Testable</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()

<span class="kw">class</span> <span class="dt">Testable</span> a <span class="kw">where</span>
<span class="ot">  property ::</span> a <span class="ot">-&gt;</span> <span class="dt">Property</span>
  <span class="co">-- the Property type will be explained later</span>

<span class="kw">instance</span> <span class="dt">Testable</span> <span class="dt">Bool</span> <span class="kw">where</span><span class="fu">...</span>

<span class="kw">instance</span> (<span class="dt">Arbitrary</span> a, <span class="dt">Show</span> a, <span class="dt">Testable</span> b) <span class="ot">=&gt;</span> <span class="dt">Testable</span> (a <span class="ot">-&gt;</span> b) <span class="kw">where</span>
  property f <span class="fu">=</span> forAll arbitrary f

<span class="kw">class</span> <span class="dt">Arbitrary</span> a <span class="kw">where</span>
<span class="ot">  arbitrary   ::</span> <span class="dt">Gen</span> a

<span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Gen</span> <span class="kw">where</span> <span class="fu">...</span></code></pre></div>
</div>
<div id="random-number-generation" class="slide section level1">
<h1>Random number generation</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">System.Random</span>
  ( <span class="dt">StdGen</span>       <span class="co">-- :: *</span>
  , newStdGen    <span class="co">-- :: IO StdGen</span>
  , randomR      <span class="co">-- :: (RandomGen g, Random a) =&gt; (a, a) -&gt; g -&gt; (a, g)</span>
  , split        <span class="co">-- :: RandomGen g =&gt; g -&gt; (g, g)</span>
                 <span class="co">-- splits its argument into independent generators</span>
  <span class="co">-- class RandomGen where</span>
  <span class="co">--   next     :: g -&gt; (Int, g)</span>
  <span class="co">--   split    :: g -&gt; (g, g)</span>
  <span class="co">-- instance RandomGen StdGen</span>
  <span class="co">-- instance Random Int</span>
  )

<span class="ot">roll ::</span> <span class="dt">StdGen</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
roll rnd <span class="fu">=</span> fst <span class="fu">$</span> randomR (<span class="dv">1</span>,<span class="dv">6</span>) rnd
main <span class="fu">=</span> <span class="kw">do</span>
  rnd <span class="ot">&lt;-</span> newStdGen
  <span class="kw">let</span> (r1,r2) <span class="fu">=</span> split rnd
  print (roll r1)
  print (roll r2)
  print (roll r1)
  print (roll r2)</code></pre></div>
<pre><code>*Main System.Random&gt; main
4
5
4
5</code></pre>
</div>
<div id="random-object-generation" class="slide section level1">
<h1>Random object generation</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">choose ::</span> (<span class="dt">Int</span>,<span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Gen</span> <span class="dt">Int</span>
<span class="ot">oneof ::</span> [<span class="dt">Gen</span> a] <span class="ot">-&gt;</span> <span class="dt">Gen</span> a

<span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">Int</span> <span class="kw">where</span>
    arbitrary <span class="fu">=</span> choose (<span class="fu">-</span><span class="dv">100</span>, <span class="dv">100</span>)

<span class="kw">data</span> <span class="dt">Colour</span> <span class="fu">=</span> <span class="dt">Red</span> <span class="fu">|</span> <span class="dt">Green</span> <span class="fu">|</span> <span class="dt">Blue</span>

<span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">Colour</span> <span class="kw">where</span>
    arbitrary <span class="fu">=</span> oneof [return <span class="dt">Red</span>, return <span class="dt">Green</span>, return <span class="dt">Blue</span>]

<span class="kw">instance</span> <span class="dt">Arbitrary</span> a <span class="ot">=&gt;</span> <span class="dt">Arbitrary</span> [a] <span class="kw">where</span>
    arbitrary <span class="fu">=</span> oneof [return [], liftM2 (<span class="fu">:</span>) arbitrary arbitrary]

<span class="ot">generate ::</span> <span class="dt">Gen</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</code></pre></div>
<p>What is the expected value of the length of a random list generated this way?</p>
<p><span class="math display">\[ \sum_{n=0}^\infty {n\over 2^{n+1}} = 1 \]</span></p>
</div>
<div id="adjusting-distribution" class="slide section level1">
<h1>Adjusting distribution:</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">frequency ::</span> [(<span class="dt">Int</span>, <span class="dt">Gen</span> a)] <span class="ot">-&gt;</span> <span class="dt">Gen</span> a

<span class="kw">instance</span> <span class="dt">Arbitrary</span> a <span class="ot">=&gt;</span> <span class="dt">Arbitrary</span> [a] <span class="kw">where</span>
  arbitrary <span class="fu">=</span> frequency
    [ (<span class="dv">1</span>, return [])
    , (<span class="dv">4</span>, liftM2 (<span class="fu">:</span>) arbitrary arbitrary)
    ]

<span class="kw">data</span> <span class="dt">Tree</span> a <span class="fu">=</span> <span class="dt">Leaf</span> a <span class="fu">|</span> <span class="dt">Branch</span> (<span class="dt">Tree</span> a) (<span class="dt">Tree</span> a)

<span class="kw">instance</span> <span class="dt">Arbitrary</span> a <span class="ot">=&gt;</span> <span class="dt">Arbitrary</span> (<span class="dt">Tree</span> a) <span class="kw">where</span>
    arbitrary <span class="fu">=</span> frequency
        [(<span class="dv">1</span>, liftM <span class="dt">Leaf</span> arbitrary)
        ,(<span class="dv">2</span>, liftM2 <span class="dt">Branch</span> arbitrary arbitrary)
        ]

<span class="ot">threetrees ::</span> <span class="dt">Gen</span> [<span class="dt">Tree</span> <span class="dt">Int</span>]
threetrees <span class="fu">=</span> sequence [arbitrary, arbitrary, arbitrary]</code></pre></div>
<p>what is the probability that generating a tree ever stops?</p>
<p><span class="math display">\[ p = {1\over 3} + {2\over 3} p^2 \]</span></p>
<p><span class="math display">\[ p = 1/2 \]</span></p>
<p>For <code>threetrees</code> it's only 1/8</p>
</div>
<div id="limiting-size" class="slide section level1">
<h1>Limiting size</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- A generator given the desired size and an StdGen yields an a</span>
<span class="kw">newtype</span> <span class="dt">Gen</span> a <span class="fu">=</span> <span class="dt">Gen</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">StdGen</span> <span class="ot">-&gt;</span> a)

<span class="ot">chooseInt1 ::</span> (<span class="dt">Int</span>,<span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Gen</span> <span class="dt">Int</span>
chooseInt1 bounds <span class="fu">=</span> <span class="dt">Gen</span> <span class="fu">$</span> \n r  <span class="ot">-&gt;</span> fst (randomR bounds r)

<span class="co">-- | `sized` builds a generator from a size-indexed generator family</span>
<span class="ot">sized ::</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Gen</span> a) <span class="ot">-&gt;</span> <span class="dt">Gen</span> a
sized fgen <span class="fu">=</span> <span class="dt">Gen</span> (\n r <span class="ot">-&gt;</span> <span class="kw">let</span> <span class="dt">Gen</span> m <span class="fu">=</span> fgen n <span class="kw">in</span> m n r)

<span class="co">-- | `resize` builds a constant size generator</span>
<span class="ot">resize ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Gen</span> a <span class="ot">-&gt;</span> <span class="dt">Gen</span> a
resize n (<span class="dt">Gen</span> m) <span class="fu">=</span> <span class="dt">Gen</span> (\_ r <span class="ot">-&gt;</span> m n r)</code></pre></div>
</div>
<div id="better-arbitrary-for-tree" class="slide section level1">
<h1>Better <code>Arbitrary</code> for <code>Tree</code></h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Arbitrary</span> a <span class="ot">=&gt;</span> <span class="dt">Arbitrary</span> (<span class="dt">Tree</span> a) <span class="kw">where</span>
    arbitrary <span class="fu">=</span> sized arbTree

arbTree <span class="dv">0</span> <span class="fu">=</span> liftM <span class="dt">Leaf</span> arbitrary
arbTree n <span class="fu">=</span> frequency
        [(<span class="dv">1</span>, liftM <span class="dt">Leaf</span> arbitrary)
        ,(<span class="dv">4</span>, liftM2 <span class="dt">Branch</span> (arbTree (div n <span class="dv">2</span>))(arbTree (div n <span class="dv">2</span>)))
        ]</code></pre></div>
</div>
<div id="a-monad-of-generators" class="slide section level1">
<h1>A monad of generators</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Resembles the state monad, but the state gets split in two</span>
<span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Gen</span> <span class="kw">where</span>
  return a <span class="fu">=</span> <span class="dt">Gen</span> <span class="fu">$</span> \n r <span class="ot">-&gt;</span> a
  <span class="dt">Gen</span> m <span class="fu">&gt;&gt;=</span> k <span class="fu">=</span> <span class="dt">Gen</span> <span class="fu">$</span> \n r0 <span class="ot">-&gt;</span>
    <span class="kw">let</span> (r1,r2) <span class="fu">=</span> split r0
        <span class="dt">Gen</span> m&#39;  <span class="fu">=</span> k (m n r1)
     <span class="kw">in</span> m&#39; n r2

<span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Gen</span> <span class="kw">where</span>
  fmap f m <span class="fu">=</span> m <span class="fu">&gt;&gt;=</span> return <span class="fu">.</span> f

<span class="ot">chooseInt ::</span> (<span class="dt">Int</span>,<span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Gen</span> <span class="dt">Int</span>
chooseInt bounds <span class="fu">=</span> (fst <span class="fu">.</span> randomR bounds) <span class="ot">`fmap`</span> rand

<span class="ot">rand ::</span> <span class="dt">Gen</span> <span class="dt">StdGen</span>
rand <span class="fu">=</span> <span class="dt">Gen</span> (\n r <span class="ot">-&gt;</span> r)

<span class="ot">choose ::</span>  <span class="dt">Random</span> a <span class="ot">=&gt;</span> (a, a) <span class="ot">-&gt;</span> <span class="dt">Gen</span> a
choose bounds <span class="fu">=</span> (fst <span class="fu">.</span> randomR bounds) <span class="ot">`fmap`</span> rand</code></pre></div>
</div>
<div id="arbitrary" class="slide section level1">
<h1>Arbitrary</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Arbitrary</span> a <span class="kw">where</span>
<span class="ot">  arbitrary   ::</span> <span class="dt">Gen</span> a

<span class="ot">elements ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Gen</span> a
elements xs <span class="fu">=</span> (xs <span class="fu">!!</span>) <span class="fu">&lt;$&gt;</span> choose (<span class="dv">0</span>, length xs <span class="fu">-</span> <span class="dv">1</span>)

<span class="ot">vector ::</span> <span class="dt">Arbitrary</span> a <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Gen</span> [a]
vector n <span class="fu">=</span> sequence [ arbitrary <span class="fu">|</span> i <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span>n] ]
<span class="co">-- sequence :: Monad m =&gt; [m a] -&gt; m [a]</span>
<span class="kw">instance</span> <span class="dt">Arbitrary</span> () <span class="kw">where</span>
  arbitrary <span class="fu">=</span> return ()

<span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">Bool</span> <span class="kw">where</span>
  arbitrary     <span class="fu">=</span> elements [<span class="dt">True</span>, <span class="dt">False</span>]

<span class="kw">instance</span> <span class="dt">Arbitrary</span> a <span class="ot">=&gt;</span> <span class="dt">Arbitrary</span> [a] <span class="kw">where</span>
  arbitrary          <span class="fu">=</span> sized (\n <span class="ot">-&gt;</span> choose (<span class="dv">0</span>,n) <span class="fu">&gt;&gt;=</span> vector)

<span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">Int</span> <span class="kw">where</span>
  arbitrary     <span class="fu">=</span> sized <span class="fu">$</span> \n <span class="ot">-&gt;</span> choose (<span class="fu">-</span>n,n)</code></pre></div>
</div>
<div id="result-of-a-test" class="slide section level1">
<h1>Result of a test</h1>
<p>A test can have one of three outcomes:</p>
<ul>
<li>Just True - success</li>
<li>Just False - failure (plus counterexample)</li>
<li>Nothing - data not fitting for the test</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Result</span> <span class="fu">=</span> <span class="dt">Result</span> {<span class="ot"> ok ::</span> <span class="dt">Maybe</span> <span class="dt">Bool</span>,<span class="ot"> arguments ::</span> [<span class="dt">String</span>] }

<span class="ot">nothing ::</span> <span class="dt">Result</span>
nothing <span class="fu">=</span> <span class="dt">Result</span>{ ok <span class="fu">=</span> <span class="dt">Nothing</span>,  arguments <span class="fu">=</span> [] }

<span class="kw">newtype</span> <span class="dt">Property</span>
  <span class="fu">=</span> <span class="dt">Prop</span> (<span class="dt">Gen</span> <span class="dt">Result</span>)</code></pre></div>
<p><code>Property</code>, is a computation in the <code>Gen</code> monad, yielding <code>Result</code></p>
</div>
<div id="testable" class="slide section level1">
<h1>Testable</h1>
<p>To test something, we need a <code>Result</code> generator</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Testable</span> a <span class="kw">where</span>
<span class="ot">  property ::</span> a <span class="ot">-&gt;</span> <span class="dt">Property</span>

<span class="ot">result ::</span> <span class="dt">Result</span> <span class="ot">-&gt;</span> <span class="dt">Property</span>
result res <span class="fu">=</span> <span class="dt">Prop</span> (return res)

<span class="kw">instance</span> <span class="dt">Testable</span> () <span class="kw">where</span>
  property () <span class="fu">=</span> result nothing

<span class="kw">instance</span> <span class="dt">Testable</span> <span class="dt">Bool</span> <span class="kw">where</span>
  property b <span class="fu">=</span> result (nothing { ok <span class="fu">=</span> <span class="dt">Just</span> b })

<span class="kw">instance</span> <span class="dt">Testable</span> <span class="dt">Property</span> <span class="kw">where</span>
  property prop <span class="fu">=</span> prop</code></pre></div>
<pre><code>*SimpleCheck1&gt; check True
OK, passed 100 tests
*SimpleCheck1&gt; check False
Falsifiable, after 0 tests:</code></pre>
</div>
<div id="running-tests" class="slide section level1">
<h1>Running tests</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">generate ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">StdGen</span> <span class="ot">-&gt;</span> <span class="dt">Gen</span> a <span class="ot">-&gt;</span> a

<span class="ot">tests ::</span> <span class="dt">Gen</span> <span class="dt">Result</span> <span class="ot">-&gt;</span> <span class="dt">StdGen</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
tests gen rnd0 ntest nfail
  <span class="fu">|</span> ntest <span class="fu">==</span> configMaxTest <span class="fu">=</span> <span class="kw">do</span> done <span class="st">&quot;OK, passed&quot;</span> ntest
  <span class="fu">|</span> nfail <span class="fu">==</span> configMaxFail <span class="fu">=</span> <span class="kw">do</span> done <span class="st">&quot;Arguments exhausted after&quot;</span> ntest
  <span class="fu">|</span> otherwise               <span class="fu">=</span>
         <span class="kw">case</span> ok result <span class="kw">of</span>
           <span class="dt">Nothing</span>    <span class="ot">-&gt;</span>
             tests gen rnd1 ntest (nfail<span class="fu">+</span><span class="dv">1</span>)
           <span class="dt">Just</span> <span class="dt">True</span>  <span class="ot">-&gt;</span>
             tests gen rnd1 (ntest<span class="fu">+</span><span class="dv">1</span>) nfail
           <span class="dt">Just</span> <span class="dt">False</span> <span class="ot">-&gt;</span>
             putStr ( <span class="st">&quot;Falsifiable, after &quot;</span>
                   <span class="fu">++</span> show ntest
                   <span class="fu">++</span> <span class="st">&quot; tests:\n&quot;</span>
                   <span class="fu">++</span> unlines (arguments result)
                    )
     <span class="kw">where</span>
      result      <span class="fu">=</span> generate (configSize ntest) rnd2 gen
      (rnd1,rnd2) <span class="fu">=</span> split rnd0</code></pre></div>
</div>
<div id="forall" class="slide section level1">
<h1>forAll</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | `evaluate` extracts a generator from the `Testable` instance</span>
<span class="ot">evaluate ::</span> <span class="dt">Testable</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Gen</span> <span class="dt">Result</span>
evaluate a <span class="fu">=</span> gen <span class="kw">where</span> <span class="dt">Prop</span> gen <span class="fu">=</span> property a

<span class="ot">forAll ::</span> (<span class="dt">Show</span> a, <span class="dt">Testable</span> b) <span class="ot">=&gt;</span> <span class="dt">Gen</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Property</span>
forAll gen body <span class="fu">=</span> <span class="dt">Prop</span> <span class="fu">$</span>
  <span class="kw">do</span> a   <span class="ot">&lt;-</span> gen
     res <span class="ot">&lt;-</span> evaluate (body a)
     return (argument a res)
 <span class="kw">where</span>
  argument a res <span class="fu">=</span> res{ arguments <span class="fu">=</span> show a <span class="fu">:</span> arguments res }


propAddCom1,<span class="ot"> propAddCom2 ::</span> <span class="dt">Property</span>
propAddCom1 <span class="fu">=</span>  forAll (chooseInt (<span class="fu">-</span><span class="dv">100</span>,<span class="dv">100</span>)) (\x <span class="ot">-&gt;</span> x <span class="fu">+</span> <span class="dv">1</span> <span class="fu">==</span> <span class="dv">1</span> <span class="fu">+</span> x)
propAddCom2 <span class="fu">=</span>  forAll int (\x <span class="ot">-&gt;</span> forAll int (\y <span class="ot">-&gt;</span> x <span class="fu">+</span> y <span class="fu">==</span> y <span class="fu">+</span> x)) <span class="kw">where</span>
  int <span class="fu">=</span> chooseInt (<span class="fu">-</span><span class="dv">100</span>,<span class="dv">100</span>)</code></pre></div>
<pre><code>&gt;&gt;&gt; check $ forAll (chooseInt (-100,100)) (\x -&gt; x + 0 == x)
OK, passed 100 tests
&gt;&gt;&gt; check $ forAll (chooseInt (-100,100)) (\x -&gt; x + 1 == x)
Falsifiable, after 0 tests:
-22</code></pre>
</div>
<div id="functions-and-implication" class="slide section level1">
<h1>Functions and implication</h1>
<p>Given <code>forAll</code>, functions are surprisingly easy:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="dt">Arbitrary</span> a, <span class="dt">Show</span> a, <span class="dt">Testable</span> b) <span class="ot">=&gt;</span> <span class="dt">Testable</span> (a <span class="ot">-&gt;</span> b) <span class="kw">where</span>
  property f <span class="fu">=</span> forAll arbitrary f

<span class="ot">propAddCom3 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
propAddCom3 x y <span class="fu">=</span> x <span class="fu">+</span> y <span class="fu">==</span> y <span class="fu">+</span> x</code></pre></div>
<p>Implication: test q, providing data satisfies p</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(==&gt;) ::</span> <span class="dt">Testable</span> a <span class="ot">=&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Property</span>
<span class="dt">True</span>  <span class="fu">==&gt;</span> a <span class="fu">=</span> property a
<span class="dt">False</span> <span class="fu">==&gt;</span> a <span class="fu">=</span> property () <span class="co">-- bad test data</span>

<span class="ot">propMul1 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Property</span>
propMul1 x <span class="fu">=</span> (x<span class="fu">&gt;</span><span class="dv">0</span>) <span class="fu">==&gt;</span> (<span class="dv">2</span><span class="fu">*</span>x <span class="fu">&gt;</span> <span class="dv">0</span>)

<span class="ot">propMul2 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Property</span>
propMul2 x y <span class="fu">=</span> (x<span class="fu">&gt;</span><span class="dv">0</span>) <span class="fu">==&gt;</span> (x<span class="fu">*</span>y <span class="fu">&gt;</span> <span class="dv">0</span>)</code></pre></div>
<pre><code>&gt; check propMul1
OK, passed 100 tests

&gt; check propMul2
Falsifiable, after 0 tests:
2
-2</code></pre>
</div>
<div id="generating-functions" class="slide section level1">
<h1>Generating functions</h1>
<p>We can test functions, but to test higher-order functons we need to generate random functions.</p>
<p>Note that</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Gen</span> a <span class="fu">~</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">StdGen</span> <span class="ot">-&gt;</span> a)
<span class="dt">Gen</span>(a <span class="ot">-&gt;</span> b) ≃ (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">StdGen</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) ≃ (a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">StdGen</span> <span class="ot">-&gt;</span> b) ≃ (a <span class="ot">-&gt;</span> <span class="dt">Gen</span> b)</code></pre></div>
<p>so we can write</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">promote ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Gen</span> b) <span class="ot">-&gt;</span> <span class="dt">Gen</span> (a <span class="ot">-&gt;</span> b)
promote f <span class="fu">=</span> <span class="dt">Gen</span> (\n r <span class="ot">-&gt;</span> \a <span class="ot">-&gt;</span> <span class="kw">let</span> <span class="dt">Gen</span> m <span class="fu">=</span> f a <span class="kw">in</span> m n r)</code></pre></div>
<p>We can use <code>promote</code> to construct a function generator if we can create a generator for results depending somehow on arguments</p>
</div>
<div id="coarbitrary" class="slide section level1">
<h1>Coarbitrary</h1>
<p>We can describe this with a class:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">CoArbitrary</span> a <span class="kw">where</span>
<span class="ot">  coarbitrary ::</span> a <span class="ot">-&gt;</span> <span class="dt">Gen</span> b <span class="ot">-&gt;</span> <span class="dt">Gen</span> b</code></pre></div>
<p><code>coarbitrary</code> produces a generator transformer from its argument</p>
<p>Now we can use <code>Coarbitrary</code> to define <code>Arbitrary</code> instance for functions:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="dt">CoArbitrary</span> a, <span class="dt">Arbitrary</span> b) <span class="ot">=&gt;</span> <span class="dt">Arbitrary</span>(a<span class="ot">-&gt;</span>b) <span class="kw">where</span>
  arbitrary <span class="fu">=</span> promote <span class="fu">$</span> \a <span class="ot">-&gt;</span> coarbitrary a arbitrary</code></pre></div>
<p>NB in newer versions of QuickCheck <code>coarbitrary</code> is a method of <code>Arbitrary</code>.</p>
<p><strong>Exercise:</strong> write a few instances of <code>Arbitrary</code> for your types. You may start with <code>coarbitrary = undefined</code></p>
</div>
<div id="coarbitrary-instances" class="slide section level1">
<h1>CoArbitrary instances</h1>
<p>To define CoArbitrary instances</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">CoArbitrary</span> <span class="kw">where</span>
<span class="ot">  coarbitrary ::</span> a <span class="ot">-&gt;</span> <span class="dt">Gen</span> b <span class="ot">-&gt;</span> <span class="dt">Gen</span> b</code></pre></div>
<p>we need a way to construct generator transformers. Let us define the function</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">variant ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Gen</span> a <span class="ot">-&gt;</span> <span class="dt">Gen</span> a
variant v (<span class="dt">Gen</span> m) <span class="fu">=</span> <span class="dt">Gen</span> (\n r <span class="ot">-&gt;</span> m n (rands r <span class="fu">!!</span> (v<span class="fu">+</span><span class="dv">1</span>)))
 <span class="kw">where</span>
  rands r0 <span class="fu">=</span> r1 <span class="fu">:</span> rands r2 <span class="kw">where</span> (r1, r2) <span class="fu">=</span> split r0</code></pre></div>
<p>which splits the input generator into many variants and chooses one of them depending on the argument</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">CoArbitrary</span> <span class="dt">Bool</span> <span class="kw">where</span>
  coarbitrary <span class="dt">False</span> <span class="fu">=</span> variant <span class="dv">0</span>
  coarbitrary <span class="dt">True</span>  <span class="fu">=</span> variant <span class="dv">1</span></code></pre></div>
</div>
<div id="example-coarbitrary-for-trees" class="slide section level1">
<h1>Example: coarbitrary for trees</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">Tree</span> <span class="kw">where</span>
  arbitrary <span class="fu">=</span> sized tree&#39;
    <span class="kw">where</span> tree&#39; <span class="dv">0</span> <span class="fu">=</span> liftM <span class="dt">Leaf</span> arbitrary
      tree&#39; n <span class="fu">|</span> n<span class="fu">&gt;</span><span class="dv">0</span> <span class="fu">=</span>
        oneof [liftM <span class="dt">Leaf</span> arbitrary,
              liftM2 <span class="dt">Branch</span> subtree subtree]
        <span class="kw">where</span> subtree <span class="fu">=</span> tree&#39; (n <span class="ot">`div`</span> <span class="dv">2</span>)

  coarbitrary (<span class="dt">Leaf</span> n) <span class="fu">=</span>
    variant <span class="dv">0</span> <span class="fu">.</span> coarbitrary n  <span class="co">--</span>
    <span class="co">-- coarbitrary n :: Gen T -&gt; Gen T</span>
    <span class="co">-- variant 0 :: Gen T -&gt; Gen T</span>

  coarbitrary (<span class="dt">Branch</span> t1 t2) <span class="fu">=</span>
    variant <span class="dv">1</span> <span class="fu">.</span> coarbitrary t1 <span class="fu">.</span> coarbitrary t2</code></pre></div>
<pre><code>variant :: Int -&gt; Gen a -&gt; Gen a
coarbitrary :: a -&gt; Gen b -&gt; Gen b</code></pre>
</div>
<div id="function-properties" class="slide section level1">
<h1>Function properties</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">infix <span class="dv">4</span> <span class="fu">===</span>
(<span class="fu">===</span>)  f g x <span class="fu">=</span> f x <span class="fu">==</span> g x

<span class="kw">instance</span> <span class="dt">Show</span>(a<span class="ot">-&gt;</span>b) <span class="kw">where</span>
  show f <span class="fu">=</span> <span class="st">&quot;&lt;function&gt;&quot;</span>

propCompAssoc f g h <span class="fu">=</span> (f <span class="fu">.</span> g) <span class="fu">.</span> h <span class="fu">===</span> f <span class="fu">.</span> (g <span class="fu">.</span> h)
  <span class="kw">where</span> types <span class="fu">=</span> [f,g,<span class="ot">h::</span><span class="dt">Int</span><span class="ot">-&gt;</span><span class="dt">Int</span>]</code></pre></div>
</div>
<div id="a-problem-with-the-implication" class="slide section level1">
<h1>A problem with the implication</h1>
<pre><code>prop_insert1 x xs = ordered (insert x xs)

*Main Test.QuickCheck&gt; quickCheck prop_insert1
*** Failed! Falsifiable (after 6 tests and 7 shrinks):
0
[0,-1]</code></pre>
<p>...obviously...</p>
<pre><code>prop_insert2 x xs = ordered xs ==&gt; ordered (insert x xs)

&gt;&gt;&gt; quickCheck prop_insert2
*** Gave up! Passed only 43 tests.</code></pre>
<p>Probability that a random list is ordered is small...</p>
<pre><code>prop_insert3 x xs = collect (length xs) $  ordered xs ==&gt; ordered (insert x xs)

&gt;&gt;&gt; quickCheck prop_insert3
*** Gave up! Passed only 37 tests:
51% 0
32% 1
16% 2</code></pre>
<p>...and those which are, are usually not very useful</p>
</div>
<div id="sometimes-you-need-to-write-your-ow-generator" class="slide section level1">
<h1>Sometimes you need to write your ow generator</h1>
<ul>
<li>Define a new type</li>
</ul>
<pre><code>newtype OrderedInts = OrderedInts [Int]

prop_insert4 :: Int -&gt; OrderedInts -&gt; Bool
prop_insert4  x (OrderedInts xs) = ordered (insert x xs)

&gt;&gt;&gt; sample (arbitrary:: Gen OrderedInts)
OrderedInts []
OrderedInts [0,0]
OrderedInts [-2,-1,2]
OrderedInts [-4,-2,0,0,2,4]
OrderedInts [-7,-6,-6,-5,-2,-1,5]
OrderedInts [-13,-12,-11,-10,-10,-7,1,1,1,10]
OrderedInts [-13,-10,-7,-5,-2,3,10,10,13]
OrderedInts [-19,-4,26]
OrderedInts [-63,-15,37]
OrderedInts [-122,-53,-47,-43,-21,-19,29,53]</code></pre>
</div>
<div id="doctest-quickcheck" class="slide section level1">
<h1>doctest + QuickCheck</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Fib</span> <span class="kw">where</span>

<span class="co">-- $setup</span>
<span class="co">-- &gt;&gt;&gt; import Control.Applicative</span>
<span class="co">-- &gt;&gt;&gt; import Test.QuickCheck</span>
<span class="co">-- &gt;&gt;&gt; newtype Small = Small Int deriving Show</span>
<span class="co">-- &gt;&gt;&gt; instance Arbitrary Small where arbitrary = Small . (`mod` 10) &lt;$&gt; arbitrary</span>

<span class="co">-- | Compute Fibonacci numbers</span>
<span class="co">--</span>
<span class="co">-- The following property holds:</span>
<span class="co">--</span>
<span class="co">-- prop&gt; \(Small n) -&gt; fib n == fib (n + 2) - fib (n + 1)</span>
<span class="ot">fib ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
fib <span class="dv">0</span> <span class="fu">=</span> <span class="dv">0</span>
fib <span class="dv">1</span> <span class="fu">=</span> <span class="dv">1</span>
fib n <span class="fu">=</span> fib (n <span class="fu">-</span> <span class="dv">1</span>) <span class="fu">+</span> fib (n <span class="fu">-</span> <span class="dv">2</span>)</code></pre></div>
<pre><code>stack install QuickCheck
stack exec doctest Fib.hs
Run from outside a project, using implicit global project config
Using resolver: lts-9.21 from implicit global project&#39;s config file: /Users/ben/.stack/global/stack.yaml
Examples: 5  Tried: 5  Errors: 0  Failures: 0</code></pre>
</div>
<div id="running-all-tests-in-a-module" class="slide section level1">
<h1>Running all tests in a module</h1>
<p><code>quickCheckAll</code> tests all properties with names starting with <code>prop_</code> (and proper type). It uses TemplateHaskell.</p>
<p>The next lecture will discuss how such functions work.</p>
<p>Usage example</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span>
<span class="kw">import </span><span class="dt">Test.QuickCheck</span>

<span class="ot">prop_AddCom3 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
prop_AddCom3 x y <span class="fu">=</span> x <span class="fu">+</span> y <span class="fu">==</span> y <span class="fu">+</span> x

<span class="ot">prop_Mul1 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Property</span>
prop_Mul1 x <span class="fu">=</span> (x<span class="fu">&gt;</span><span class="dv">0</span>) <span class="fu">==&gt;</span> (<span class="dv">2</span><span class="fu">*</span>x <span class="fu">&gt;</span> <span class="dv">0</span>)

return []  <span class="co">-- tells TH to typecheck definitions above and insert an empty decl list</span>
runTests <span class="fu">=</span> <span class="fu">$</span>quickCheckAll

main <span class="fu">=</span> runTests</code></pre></div>
</div>
</body>
</html>
