<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Marcin Benke" />
  <title>Advanced Functional Programming</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
</head>
<body>
<div id="header">
<h1 class="title">Advanced Functional Programming</h1>
<h2 class="author">Marcin Benke</h2>
<h3 class="date">Mar 9, 2021</h3>
</div>
<p><meta name="duration" content="80" /></p>
<h1 id="course-plan">Course plan</h1>
<ul>
<li>Types and type classes
<ul>
<li>Algebraic types and type classes</li>
<li>Constructor classes</li>
<li>Multiparameter classes, functional dependencies</li>
</ul></li>
<li>Testing (QuickCheck)</li>
<li>Dependent types, Agda, Idris, Coq, proving properties (ca 7 weeks)</li>
<li>Dependent types in Haskell
<ul>
<li>Type families, associated types, GADTs</li>
<li>data kinds, kind polymorphism</li>
</ul></li>
<li>Metaprogramming</li>
<li>Parallel and concurrent programming in Haskell
<ul>
<li>Multicore and multiprocessor programming (SMP)</li>
<li>Concurrency</li>
<li>Data Parallel Haskell</li>
</ul></li>
<li>Project presentations</li>
</ul>
<p>Any wishes?</p>
<h1 id="passing-the-course-zasady-zaliczania">Passing the course (Zasady zaliczania)</h1>
<ul>
<li>Lab: fixed Coq project, student-defined simple Haskell project (group projects are encouraged)</li>
<li>Oral exam, most important part of which is project presentation</li>
<li>Alternative to Haskell project: presentation on interesting Haskell topics during the lecture (possibly plus lab)
<ul>
<li>Anyone interested?</li>
</ul></li>
</ul>
<h1 id="materials">Materials</h1>
<pre><code>$ cabal update
$ cabal install pandoc
$ PATH=~/.cabal/bin:$PATH            # Linux
$ PATH=~/Library/Haskell/bin:$PATH   # OS X
$ git clone git://github.com/mbenke/zpf2020.git &amp;&amp; cd zpf2020
$ make</code></pre>
<p>or using stack - https://haskellstack.org/</p>
<pre><code>stack setup
stack install pandoc
export PATH=$(stack path --local-bin):$PATH
...</code></pre>
<p>On students machine, using system GHC:</p>
<pre><code>export STACK=&quot;/home/students/inf/PUBLIC/MRJP/Stack/stack --system-ghc --resolver lts-13.19&quot;
$STACK setup
$STACK config set system-ghc --global true
$STACK config set resolver lts-13.19
$STACK upgrade --force-download  # or cp stack executable to your path
#  ...
#  Should I try to perform the file copy using sudo? This may fail
#  Try using sudo? (y/n) n

export PATH=$($STACK path --local-bin):$PATH
stack install pandoc</code></pre>
<h1 id="digression---cabal-and-stack">Digression - cabal and stack</h1>
<p><strong>Common Architecture for Building Applications and Libraries</strong></p>
<p><code>cabal install</code> - lets you install libraries without root</p>
<pre><code>[ben@students Haskell]$ cabal update
Downloading the latest package list
  from hackage.haskell.org
[ben@students Haskell]$ cabal install GLFW
...kompilacja...
Installing library in
 /home/staff/iinf/ben/.cabal/lib/GLFW-0.4.2/ghc-6.10.4
Registering GLFW-0.4.2...
Reading package info from &quot;dist/installed-pkg-config&quot;
 ... done.
Writing new package config file... done.</code></pre>
<p>Many libraries on <code>http://hackage.haskell.org/</code></p>
<h1 id="cabal-hell">Cabal hell</h1>
<pre><code>$ cabal install criterion
Resolving dependencies...
In order, the following would be installed:
monad-par-extras-0.3.3 (reinstall) changes: mtl-2.1.2 -&gt; 2.2.1,
transformers-0.3.0.0 -&gt; 0.5.2.0
nats-1.1.1 (reinstall) changes: hashable-1.1.2.5 -&gt; 1.2.5.0
...
criterion-1.1.4.0 (new package)
cabal: The following packages are likely to be broken by the reinstalls:
monad-par-0.3.4.7
void-0.7.1
lens-4.15.1
...
HTTP-4000.3.3
Use --force-reinstalls if you want to install anyway.</code></pre>
<p>In newer cabal versions partially solved by sandboxing and <code>cabal new-install</code></p>
<h1 id="stack-stackage">Stack + stackage</h1>
<blockquote>
<p>Stackage is a stable source of Haskell packages. We guarantee that packages build consistently and pass tests before generating nightly and Long Term Support (LTS) releases.</p>
</blockquote>
<pre><code>LTS 15.0 for ghc-8.8.2, published a week ago
LTS 14.27 for ghc-8.6.5, published a week ago
LTS 13.19 for ghc-8.6.4, published 10 months ago
LTS 13.11 for ghc-8.6.3, published 12 months ago
LTS 12.26 for GHC 8.4.4, published a month ago
LTS 12.14 for GHC 8.4.3, published 4 months ago
LTS 11.22 for GHC 8.2.2, published 6 months ago
LTS 9.21 for GHC 8.0.2, published a year ago
LTS 7.24 for GHC 8.0.1, published a year ago
LTS 6.35 for GHC 7.10.3, published a year ago
LTS 3.22 for GHC 7.10.2, published 3 years ago
LTS 2.22 for GHC 7.8.4, published 4 years ago
LTS 0.7 for GHC 7.8.3, published 4 years ago</code></pre>
<pre><code>$ stack --resolver lts-3.22 install criterion
Run from outside a project, using implicit global project config
Using resolver: lts-3.22 specified on command line
Downloaded lts-3.22 build plan.
mtl-2.2.1: using precompiled package
...
criterion-1.1.0.0: download
criterion-1.1.0.0: configure
criterion-1.1.0.0: build
criterion-1.1.0.0: copy/register
</code></pre>
<h1 id="building-a-project">Building a project</h1>
<pre><code>$ stack new hello --resolver lts-11.22 &amp;&amp; cd hello
Downloading template &quot;new-template&quot; to create project &quot;hello&quot; in hello/ ...

Selected resolver: lts-11.22
Initialising configuration using resolver: lts-11.22
Total number of user packages considered: 1
Writing configuration to file: hello/stack.yaml
All done.

$ stack build
Building all executables for `hello&#39; once. After a successful build
of all of them, only specified executables will be rebuilt.
hello-0.1.0.0: configure (lib + exe)
...
hello-0.1.0.0: copy/register
Installing library in /home/staff/iinf/ben/tmp/hello/.stack-work/install/x86_64-linux/lts-11.22/8.2.2/lib/x86_64-linux-ghc-8.2.2/hello-0.1.0.0-CaHXYhIIKYt3q9LDFmJN3m
Installing executable hello-exe in /home/staff/iinf/ben/tmp/hello/.stack-work/install/x86_64-linux/lts-11.22/8.2.2/bin
Registering library for hello-0.1.0.0..
$ stack exec hello-exe
someFunc</code></pre>
<h1 id="stack---exercises">Stack - exercises</h1>
<ol style="list-style-type: decimal">
<li>On your own machine:
<ul>
<li>Install <code>stack</code></li>
<li>Install GHC 7.10 using <code>stack setup</code></li>
<li>Install GHC 8.6 using <code>stack setup</code></li>
<li>Run <code>stack ghci</code> with ver 7.10 and 8</li>
<li>Build and run hello project, modify it a little</li>
</ul></li>
<li>On students you can try the same, but quota can be a problem, so use system ghc instead.</li>
</ol>
<h1 id="functional-languages">Functional languages</h1>
<ul>
<li>dynamically typed, strict, impure: e.g. Lisp</li>
<li>statically typed, strict, impure: e.g. ML</li>
<li>staticaly typed, lazy, pure: e.g. Haskell</li>
</ul>
<p>This course: Haskell, focusing on types.</p>
<p>Rich type structure distinguishes Haskell among other languages.</p>
<h1 id="types-as-a-specification-language">Types as a specification language</h1>
<p>A function type often specifies not only its input and output but also relationship between them:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f ::</span> forall a<span class="fu">.</span> a <span class="ot">-&gt;</span> a
f x <span class="fu">=</span> <span class="fu">?</span></code></pre></div>
<p>If <code>f x</code> gives a result, it must be <code>x</code></p>
<ul>
<li><p>Philip Wadler &quot;Theorems for Free&quot;</p></li>
<li><p><code>h :: a -&gt; IO b</code> constructs a computation with possible side effects</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.IORef</span>

<span class="ot">f ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">IORef</span> <span class="dt">Int</span>)
f i <span class="fu">=</span> <span class="kw">do</span>
  print i
  r <span class="ot">&lt;-</span> newIORef i
  return r

main <span class="fu">=</span> <span class="kw">do</span>
  r <span class="ot">&lt;-</span> f <span class="dv">42</span>
  j <span class="ot">&lt;-</span> readIORef r
  print j</code></pre></div></li>
</ul>
<h1 id="types-as-a-specification-language-2">Types as a specification language (2)</h1>
<p><code>g :: Integer -&gt; Integer</code> may not have side effects visible outside</p>
<p>It may have local side effects</p>
<p>Example: Fibonacci numbers in constant memory</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad.ST</span>
<span class="kw">import </span><span class="dt">Data.STRef</span>
<span class="ot">fibST ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
fibST n <span class="fu">=</span>
    <span class="kw">if</span> n <span class="fu">&lt;</span> <span class="dv">2</span> <span class="kw">then</span> n <span class="kw">else</span> runST fib2 <span class="kw">where</span>
      fib2 <span class="fu">=</span>  <span class="kw">do</span>
        x <span class="ot">&lt;-</span> newSTRef <span class="dv">0</span>
        y <span class="ot">&lt;-</span> newSTRef <span class="dv">1</span>
        fib3 n x y

      fib3 <span class="dv">0</span> x _ <span class="fu">=</span> readSTRef x
      fib3 n x y <span class="fu">=</span> <span class="kw">do</span>
              x&#39; <span class="ot">&lt;-</span> readSTRef x
              y&#39; <span class="ot">&lt;-</span> readSTRef y
              writeSTRef x y&#39;
              writeSTRef y (x&#39;<span class="fu">+</span>y&#39;)
              fib3 (n<span class="fu">-</span><span class="dv">1</span>) x y</code></pre></div>
<p>How come?</p>
<pre><code>runST :: (forall s. ST s a) -&gt; a</code></pre>
<p>The type of <code>runST</code> guarantees that side effects do not leak; <code>fibST</code> is pure.</p>
<h1 id="types-as-a-design-language">Types as a design language</h1>
<ul>
<li><p>Designing programs using types and <code>undefined</code></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">conquer ::</span> [<span class="dt">Foo</span>] <span class="ot">-&gt;</span> [<span class="dt">Bar</span>]
conquer fs <span class="fu">=</span> concatMap step fs

<span class="ot">step ::</span> <span class="dt">Foo</span> <span class="ot">-&gt;</span> [<span class="dt">Bar</span>]
step <span class="fu">=</span> undefined</code></pre></div></li>
</ul>
<p>Newer Haskell version allow for typed holes.</p>
<pre><code>module Conquer where

data Foo = Foo
data Bar = Bar Foo

conquer :: [Foo] -&gt; [Bar]
conquer fs = concatMap (pure . step) fs

step :: Foo -&gt; Bar
step = _</code></pre>
<p>we get</p>
<pre><code>    • Found hole: _ :: Foo -&gt; Bar
    • In the expression: _
      In an equation for ‘step’: step = _
    • Relevant bindings include
        step :: Foo -&gt; Bar
      Valid substitutions include
        Bar :: Foo -&gt; Bar
        step :: Foo -&gt; Bar
        undefined :: forall (a :: TYPE r).
                     GHC.Stack.Types.HasCallStack =&gt;
                     a</code></pre>
<h1 id="types-as-a-programming-language">Types as a programming language</h1>
<ul>
<li><p>Functions on types computed at compile time</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Zero</span>
<span class="kw">data</span> <span class="dt">Succ</span> n

<span class="kw">type</span> <span class="dt">One</span>   <span class="fu">=</span> <span class="dt">Succ</span> <span class="dt">Zero</span>
<span class="kw">type</span> <span class="dt">Two</span>   <span class="fu">=</span> <span class="dt">Succ</span> <span class="dt">One</span>
<span class="kw">type</span> <span class="dt">Three</span> <span class="fu">=</span> <span class="dt">Succ</span> <span class="dt">Two</span>
<span class="kw">type</span> <span class="dt">Four</span>  <span class="fu">=</span> <span class="dt">Succ</span> <span class="dt">Three</span>

one   <span class="fu">=</span><span class="ot"> undefined ::</span> <span class="dt">One</span>
two   <span class="fu">=</span><span class="ot"> undefined ::</span> <span class="dt">Two</span>
three <span class="fu">=</span><span class="ot"> undefined ::</span> <span class="dt">Three</span>
four  <span class="fu">=</span><span class="ot"> undefined ::</span> <span class="dt">Four</span>

<span class="kw">class</span> <span class="dt">Add</span> a b c <span class="fu">|</span> a b <span class="ot">-&gt;</span> c <span class="kw">where</span>
<span class="ot">  add ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c
  add <span class="fu">=</span> undefined
<span class="kw">instance</span>              <span class="dt">Add</span>  <span class="dt">Zero</span>    b  b
<span class="kw">instance</span> <span class="dt">Add</span> a b c <span class="ot">=&gt;</span> <span class="dt">Add</span> (<span class="dt">Succ</span> a) b (<span class="dt">Succ</span> c)</code></pre></div>
<pre><code>*Main&gt; :t add three one
add three one :: Succ (Succ (Succ (Succ Zero)))</code></pre></li>
</ul>
<p><strong>Exercise:</strong> extend with multiplication and factorial</p>
<h1 id="types-as-a-programming-language-2">Types as a programming language (2)</h1>
<p>Vectors using type classes:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Vec</span><span class="ot"> ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="kw">where</span>
  <span class="dt">VNil</span><span class="ot"> ::</span> <span class="dt">Vec</span> <span class="dt">Zero</span> a
<span class="ot">  (:&gt;) ::</span> a <span class="ot">-&gt;</span> <span class="dt">Vec</span> n a <span class="ot">-&gt;</span> <span class="dt">Vec</span> (<span class="dt">Succ</span> n) a

<span class="ot">vhead ::</span> <span class="dt">Vec</span> (<span class="dt">Succ</span> n) a <span class="ot">-&gt;</span> a
vhead (x <span class="fu">:&gt;</span> xs) <span class="fu">=</span> x</code></pre></div>
<p><strong>Exercise:</strong> write <code>vtail</code>, <code>vlast</code></p>
<p>We would like to have</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">vappend ::</span> <span class="dt">Add</span> m n s <span class="ot">=&gt;</span> <span class="dt">Vec</span> m a <span class="ot">-&gt;</span> <span class="dt">Vec</span> n a <span class="ot">-&gt;</span> <span class="dt">Vec</span> s a</code></pre></div>
<p>but here the base type system is too weak</p>
<h1 id="types-as-a-programming-language-3">Types as a programming language (3)</h1>
<ul>
<li><p>Vectors with type families:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Zero</span> <span class="fu">=</span> <span class="dt">Zero</span>
<span class="kw">data</span> <span class="dt">Suc</span> n <span class="fu">=</span> <span class="dt">Suc</span> n

<span class="kw">type</span> family m <span class="fu">:+</span> n
<span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Zero</span> <span class="fu">:+</span> n <span class="fu">=</span> n
<span class="kw">type</span> <span class="kw">instance</span> (<span class="dt">Suc</span> m) <span class="fu">:+</span> n <span class="fu">=</span> <span class="dt">Suc</span>(m<span class="fu">:+</span>n)

<span class="kw">data</span> <span class="dt">Vec</span><span class="ot"> ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="kw">where</span>
  <span class="dt">VNil</span><span class="ot"> ::</span> <span class="dt">Vec</span> <span class="dt">Zero</span> a
<span class="ot">  (:&gt;) ::</span> a <span class="ot">-&gt;</span> <span class="dt">Vec</span> n a <span class="ot">-&gt;</span> <span class="dt">Vec</span> (<span class="dt">Suc</span> n) a

<span class="ot">vhead ::</span> <span class="dt">Vec</span> (<span class="dt">Suc</span> n) a <span class="ot">-&gt;</span> a
<span class="ot">vappend ::</span> <span class="dt">Vec</span> m a <span class="ot">-&gt;</span> <span class="dt">Vec</span> n a <span class="ot">-&gt;</span> <span class="dt">Vec</span> (m<span class="fu">:+</span>n) a</code></pre></div></li>
</ul>
<h1 id="dependent-types">Dependent types</h1>
<p>Real type-level programming and proving properties is possible in a language with dependent types, such as Agda or Idris:</p>
<pre><code>module Data.Vec where
infixr 5 _∷_

data Vec (A : Set a) : ℕ → Set where
  []  : Vec A zero
  _∷_ : ∀ {n} (x : A) (xs : Vec A n) → Vec A (suc n)

_++_ : ∀ {a m n} {A : Set a} → Vec A m → Vec A n → Vec A (m + n)
[]       ++ ys = ys
(x ∷ xs) ++ ys = x ∷ (xs ++ ys)

module UsingVectorEquality {s₁ s₂} (S : Setoid s₁ s₂) where
  xs++[]=xs : ∀ {n} (xs : Vec A n) → xs ++ [] ≈ xs
  xs++[]=xs []       = []-cong
  xs++[]=xs (x ∷ xs) = SS.refl ∷-cong xs++[]=xs xs</code></pre>
<h1 id="a-problem-with-dependent-types">A problem with dependent types</h1>
<p>While Haskell is sometimes hard to read, dependent types are even easier to overdo:</p>
<pre><code>  now-or-never : Reflexive _∼_ →
                 ∀ {k} (x : A ⊥) →
                 ¬ ¬ ((∃ λ y → x ⇓[ other k ] y) ⊎ x ⇑[ other k ])
  now-or-never refl x = helper &lt;$&gt; excluded-middle
    where
    open RawMonad ¬¬-Monad

    not-now-is-never : (x : A ⊥) → (∄ λ y → x ≳ now y) → x ≳ never
    not-now-is-never (now x)   hyp with hyp (, now refl)
    ... | ()
    not-now-is-never (later x) hyp =
      later (♯ not-now-is-never (♭ x) (hyp ∘ Prod.map id laterˡ))

    helper : Dec (∃ λ y → x ≳ now y) → _
    helper (yes ≳now) = inj₁ $ Prod.map id ≳⇒ ≳now
    helper (no  ≵now) = inj₂ $ ≳⇒ $ not-now-is-never x ≵now</code></pre>
<p>...even though writing such proofs is fun.</p>
<h1 id="parallel-haskell">Parallel Haskell</h1>
<p>Parallel Sudoku solver</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> <span class="kw">do</span>
    [f] <span class="ot">&lt;-</span> getArgs
    grids <span class="ot">&lt;-</span> fmap lines <span class="fu">$</span> readFile f
    runEval (parMap solve grids) <span class="ot">`deepseq`</span> return ()

<span class="ot">parMap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Eval</span> [b]
parMap f [] <span class="fu">=</span> return []
parMap f (a<span class="fu">:</span>as) <span class="fu">=</span> <span class="kw">do</span>
   b <span class="ot">&lt;-</span> rpar (f a)
   bs <span class="ot">&lt;-</span> parMap f as
   return (b<span class="fu">:</span>bs)

<span class="ot">solve ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Grid</span></code></pre></div>
<pre><code>$ ./sudoku3b sudoku17.1000.txt +RTS -N2 -s -RTS
  TASKS: 4 (1 bound, 3 peak workers (3 total), using -N2)
  SPARKS: 1000 (1000 converted, 0 overflowed, 0 dud, 0 GC&#39;d, 0 fizzled)

  Total   time    2.84s  (  1.49s elapsed)
  Productivity  88.9% of total user, 169.6% of total elapsed

-N8: Productivity  78.5% of total user, 569.3% of total elapsed
N16: Productivity  62.8% of total user, 833.8% of total elapsed
N32: Productivity  43.5% of total user, 1112.6% of total elapsed</code></pre>
<h1 id="parallel-fibonacci">Parallel Fibonacci</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">cutoff ::</span> <span class="dt">Int</span>
cutoff <span class="fu">=</span> <span class="dv">20</span>

parFib n <span class="fu">|</span> n <span class="fu">&lt;</span> cutoff <span class="fu">=</span> fib n
parFib n <span class="fu">=</span> p <span class="ot">`par`</span> q <span class="ot">`pseq`</span> (p <span class="fu">+</span> q)
    <span class="kw">where</span>
      p <span class="fu">=</span> parFib <span class="fu">$</span> n <span class="fu">-</span> <span class="dv">1</span>
      q <span class="fu">=</span> parFib <span class="fu">$</span> n <span class="fu">-</span> <span class="dv">2</span>

fib n <span class="fu">|</span> n<span class="fu">&lt;</span><span class="dv">2</span> <span class="fu">=</span> n
fib n <span class="fu">=</span> fib (n <span class="fu">-</span> <span class="dv">1</span>) <span class="fu">+</span> fib (n <span class="fu">-</span> <span class="dv">2</span>)</code></pre></div>
<pre><code>./parfib +RTS -N60 -s -RTS
 SPARKS: 118393 (42619 converted, 0 overflowed, 0 dud,
                 11241 GC&#39;d, 64533 fizzled)

  Total   time   17.91s  (  0.33s elapsed)
  Productivity  98.5% of total user, 5291.5% of total elapsed

-N60, cutoff=15
  SPARKS: 974244 (164888 converted, 0 overflowed, 0 dud,
                  156448 GC&#39;d, 652908 fizzled)
  Total   time   13.59s  (  0.28s elapsed)
  Productivity  97.6% of total user, 4746.9% of total elapsed</code></pre>
<h1 id="data-parallel-haskell">Data Parallel Haskell</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE ParallelArrays #-}</span>
<span class="ot">{-# OPTIONS_GHC -fvectorise #-}</span>

<span class="kw">module</span> <span class="dt">DotP</span> <span class="kw">where</span>
<span class="kw">import qualified</span> <span class="dt">Prelude</span>
<span class="kw">import </span><span class="dt">Data.Array.Parallel</span>
<span class="kw">import </span><span class="dt">Data.Array.Parallel.Prelude</span>
<span class="kw">import </span><span class="dt">Data.Array.Parallel.Prelude.Double</span> <span class="kw">as</span> <span class="dt">D</span>

<span class="ot">dotp_double ::</span> [<span class="fu">:</span><span class="dt">Double</span><span class="fu">:</span>] <span class="ot">-&gt;</span> [<span class="fu">:</span><span class="dt">Double</span><span class="fu">:</span>] <span class="ot">-&gt;</span> <span class="dt">Double</span>
dotp_double xs ys <span class="fu">=</span> D.sumP [<span class="fu">:</span>x <span class="fu">*</span> y <span class="fu">|</span> x <span class="ot">&lt;-</span> xs <span class="fu">|</span> y <span class="ot">&lt;-</span> ys<span class="fu">:</span>]</code></pre></div>
<p>Looks like list operations, but works on vectors and &quot;automagically&quot; parallellises to any number of cores (also CUDA)</p>
<h1 id="types-in-haskell">Types in Haskell</h1>
<ul>
<li>base types: <code>zeroInt :: Int</code></li>
<li>function types: <code>plusInt :: Int -&gt; Int -&gt; Int</code></li>
<li><p>polymorphic types <code>id :: a -&gt; a</code></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE ExplicitForAll #-}</span>
<span class="ot">g ::</span> forall b<span class="fu">.</span>b <span class="ot">-&gt;</span> b</code></pre></div></li>
<li>constrained types <code>0 :: Num a =&gt; a</code></li>
<li><p>algebraic types</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Tree</span> a <span class="fu">=</span> <span class="dt">Leaf</span> <span class="fu">|</span> <span class="dt">Node</span> a (<span class="dt">Tree</span> a) (<span class="dt">Tree</span> a)</code></pre></div></li>
<li><p><code>Leaf</code>, <code>Node</code> are *value constructors</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Tree</span> a <span class="kw">where</span>
     <span class="dt">Leaf</span><span class="ot"> ::</span> <span class="dt">Tree</span> a
     <span class="dt">Node</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a</code></pre></div></li>
<li><p><code>Tree</code> is a <em>type constructor</em>, an operation on types</p></li>
<li><p>NB empty types are allowed:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Zero</span></code></pre></div></li>
</ul>
<h1 id="polymorphic-typing">Polymorphic typing</h1>
<ul>
<li>Generalisation:</li>
</ul>
<p><span class="math display">\[{\Gamma \vdash e :: t, a \notin FV( \Gamma )}\over {\Gamma \vdash e :: \forall a.t}\]</span></p>
<p><!--
Jeśli $\Gamma \vdash e :: t, a \notin FV( \Gamma )$

to $\Gamma \vdash e :: \forall a.t$

  Γ ⊢ e :: t, a∉FV(Γ)
$$\Gamma \vdash e :: t$$ ,
 \(a \not\in FV(\Gamma) \) ,
to $\Gamma \vdash e :: \forall a.t$
--></p>
<p>For example</p>
<p><span class="math display">\[{ { \vdash map :: (a\to b) \to [a] \to [b] } \over
   { \vdash map :: \forall b. (a\to b) \to [a] \to [b] } } \over
   { \vdash map :: \forall a. \forall b. (a\to b) \to [a] \to [b] } \]</span></p>
<p>Note:</p>
<p><span class="math display">\[ f : a \to b \not \vdash map\; f :: \forall b. [a] \to [b]  \]</span></p>
<ul>
<li>Instantiation</li>
</ul>
<p><span class="math display">\[ {\Gamma \vdash e :: \forall a.t}\over {\Gamma \vdash e :: t[a:=s]} \]</span></p>
<h1 id="classes">Classes</h1>
<ul>
<li><p>Classes describe properties of types, e.g.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Eq</span> a <span class="kw">where</span>
<span class="ot">  (==) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="kw">instance</span> <span class="dt">Eq</span> <span class="dt">Bool</span> <span class="kw">where</span>
   <span class="dt">True</span>  <span class="fu">==</span> <span class="dt">True</span>  <span class="fu">=</span> <span class="dt">True</span>
   <span class="dt">False</span> <span class="fu">==</span> <span class="dt">False</span> <span class="fu">=</span> <span class="dt">True</span>
   _     <span class="fu">==</span> _     <span class="fu">=</span> <span class="dt">False</span>

<span class="kw">class</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> <span class="dt">Ord</span> a <span class="kw">where</span> <span class="fu">...</span></code></pre></div></li>
<li><p>types can be constrained by class context:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">elem<span class="ot"> ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span></code></pre></div></li>
<li>Implementaction
<ul>
<li>an instance is translated to a method dictionary (akin to C++ vtable)</li>
<li>context is translated to an implicit parameter (method dictionary)</li>
<li>a subclass is translated to a function on method dicts</li>
</ul></li>
</ul>
<h1 id="operations-on-types">Operations on types</h1>
<ul>
<li><p>A simple example:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Tree</span> a <span class="fu">=</span> <span class="dt">Leaf</span> <span class="fu">|</span> <span class="dt">Node</span> a (<span class="dt">Tree</span> a) (<span class="dt">Tree</span> a)</code></pre></div></li>
<li><p>Type constructors transform types</p></li>
<li><p>e.g. <code>Tree</code> maps <code>Int</code> to <code>Tree Int</code></p></li>
<li><p>Higher order functions transform functions</p></li>
<li><p>Higher order constructors transform type constructors, e.g.</p></li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">IdentityT</span> m a <span class="fu">=</span> <span class="dt">IdentityT</span> {<span class="ot"> runIdentityT ::</span> m a }</code></pre></div>
<h1 id="constructor-classes">Constructor classes</h1>
<ul>
<li><p>constructor classes describe properties of type constructors:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="kw">where</span>
<span class="ot">  fmap ::</span> (a<span class="ot">-&gt;</span>b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b
(<span class="fu">&lt;$&gt;</span>) <span class="fu">=</span> fmap

<span class="kw">instance</span> <span class="dt">Functor</span> [] <span class="kw">where</span>
  fmap <span class="fu">=</span> map

<span class="kw">class</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Pointed</span> f <span class="kw">where</span>
<span class="ot">   pure ::</span> a <span class="ot">-&gt;</span> f a
<span class="kw">instance</span> <span class="dt">Pointed</span> [] <span class="kw">where</span>
   pure <span class="fu">=</span> (<span class="fu">:</span>[])

<span class="kw">class</span> <span class="dt">Pointed</span> f <span class="ot">=&gt;</span> <span class="dt">Applicative</span> f <span class="kw">where</span>
<span class="ot">  (&lt;*&gt;) ::</span> f(a<span class="ot">-&gt;</span>b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b

<span class="kw">instance</span> <span class="dt">Applicative</span> [] <span class="kw">where</span>
  fs <span class="fu">&lt;*&gt;</span> xs <span class="fu">=</span> concat <span class="fu">$</span> flip map fs (flip map xs)

<span class="kw">class</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> <span class="dt">Monad&#39;</span> m <span class="kw">where</span>
<span class="ot">  (&gt;&gt;=) ::</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b</code></pre></div></li>
</ul>
<!--

    class Pointed f => Applicative f where
      (<*>) :: f(a->b) -> f a -> f b
      (*>) :: f a -> f b -> f b
      x *> y = (flip const) <$> x <*> y
      (<*) :: f a -> f b -> f a
      x <* y = const <$> x <*> y

    liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
    liftA2 f a b = f <$> a <*> b

-->
<h1 id="kinds">Kinds</h1>
<ul>
<li><p>Value operations are described by their types</p></li>
<li><p>Type operations are described by their kinds</p></li>
<li><p>Types (e.g.. <code>Int</code>, <code>Int -&gt; Bool</code>) are of kind <code>*</code></p></li>
<li><p>One argument constructors are of type (e.g.. <code>Tree</code>) are of kind <code>* -&gt; *</code></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-#LANGUAGE KindSignatures, ExplicitForAll #-}</span>

<span class="kw">class</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Pointed</span> (<span class="ot">f ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) <span class="kw">where</span>
<span class="ot">    pure ::</span> forall (<span class="ot">a ::</span> <span class="fu">*</span>)<span class="fu">.</span>a <span class="ot">-&gt;</span> f a</code></pre></div></li>
<li><p>More complex kinds are possible, e.g. for monad transformers:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">MonadTrans</span> (<span class="ot">t ::</span> (<span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) <span class="kw">where</span>
<span class="ot">    lift ::</span> <span class="dt">Monad</span> (<span class="ot">m ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) <span class="ot">=&gt;</span> forall (<span class="ot">a ::</span> <span class="fu">*</span>)<span class="fu">.</span>m a <span class="ot">-&gt;</span> t m a</code></pre></div></li>
</ul>
<p>NB spaces are obligatory - <code>::*-&gt;*</code> is one lexem</p>
<p>Newer Haskell versions allow introducing user kinds - we'll talk about them later.</p>
<h1 id="multiparameter-typeclasses">Multiparameter typeclasses</h1>
<ul>
<li><p>Sometimes we need to describe a relationship between types rather than just a single type:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-#LANGUAGE MultiParamTypeClasses, FlexibleInstances #-}</span>
<span class="kw">class</span> <span class="dt">Iso</span> a b <span class="kw">where</span>
<span class="ot">  iso ::</span> a <span class="ot">-&gt;</span> b
<span class="ot">  osi ::</span> b <span class="ot">-&gt;</span> a

<span class="kw">instance</span> <span class="dt">Iso</span> a a <span class="kw">where</span>
  iso <span class="fu">=</span> id
  osi <span class="fu">=</span> id

<span class="kw">instance</span> <span class="dt">Iso</span> ((a,b)<span class="ot">-&gt;</span>c) (a<span class="ot">-&gt;</span>b<span class="ot">-&gt;</span>c) <span class="kw">where</span>
  iso <span class="fu">=</span> curry
  osi <span class="fu">=</span> uncurry

<span class="kw">instance</span> (<span class="dt">Iso</span> a b) <span class="ot">=&gt;</span> <span class="dt">Iso</span> [a] [b] <span class="kw">where</span>
 iso <span class="fu">=</span> map iso
 osi <span class="fu">=</span> map osi</code></pre></div></li>
<li><p>NB: in the last example <code>iso</code> has a different type on the left than on the right.</p></li>
<li><p>Exercise: write more instances of <code>Iso</code>, e.g.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="dt">Functor</span> f, <span class="dt">Iso</span> a b) <span class="ot">=&gt;</span> <span class="dt">Iso</span> (f a) (f b) <span class="kw">where</span>
<span class="kw">instance</span> <span class="dt">Iso</span> (a<span class="ot">-&gt;</span>b<span class="ot">-&gt;</span>c) (b<span class="ot">-&gt;</span>a<span class="ot">-&gt;</span>c) <span class="kw">where</span></code></pre></div></li>
</ul>
<h1 id="digression---flexibleinstances">Digression - FlexibleInstances</h1>
<p>Haskell 2010</p>
<!--
An instance declaration introduces an instance of a class. Let class
cx => C u where { cbody } be a class declaration. The general form of
the corresponding instance declaration is: instance cx′ => C (T u1 …
uk) where { d } where k ≥ 0. The type (T u1 … uk) must take the form
of a type constructor T applied to simple type variables u1, … uk;
furthermore, T must not be a type synonym, and the ui must all be
distinct.
-->
<ul>
<li>an instance head must have the form <code>C (T u1 ... uk)</code>, where <code>T</code> is a type constructor defined by a data or newtype declaration and the <code>u_i</code> are distinct type variables</li>
</ul>
<!--
*    and each assertion in the context must have the form C' v, where v is one of the ui.
-->
<p>This prohibits instance declarations such as:</p>
<pre><code>  instance C (a,a) where ...
  instance C (Int,a) where ...
  instance C [[a]] where ...</code></pre>
<p><code>instance Iso a a</code> does not meet these conditions, but it's easy to see what relation we mean.</p>
<h1 id="problem-with-muliparameter-type-classes">Problem with muliparameter type classes</h1>
<p>Consider a class of collections, e.g.</p>
<p><code>BadCollection.hs</code></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Collection</span> c <span class="kw">where</span>
<span class="ot">  insert ::</span> e <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> c
<span class="ot">  member ::</span> e <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> <span class="dt">Bool</span>

<span class="kw">instance</span> <span class="dt">Collection</span> [a] <span class="kw">where</span>
     insert <span class="fu">=</span> (<span class="fu">:</span>)
     member <span class="fu">=</span> elem</code></pre></div>
<p>we get an error:</p>
<pre><code>    Couldn&#39;t match type `e&#39; with `a&#39;
      `e&#39; is a rigid type variable bound by
          the type signature for member :: e -&gt; [a] -&gt; Bool
          at BadCollection.hs:7:6
      `a&#39; is a rigid type variable bound by
          the instance declaration
          at BadCollection.hs:5:22</code></pre>
<p>Why?</p>
<h1 id="problem-with-muliparameter-type-classes-1">Problem with muliparameter type classes</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Collection</span> c <span class="kw">where</span>
<span class="ot"> insert ::</span> e <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> c
<span class="ot"> member ::</span> e <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> <span class="dt">Bool</span></code></pre></div>
<p>translates more or less to</p>
<pre><code>data ColDic c = CD
 {
 , insert :: forall e.e -&gt; c -&gt; c
 , member :: forall e.e -&gt; c -&gt; Bool
 }</code></pre>
<p>... this is not what we meant</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Collection</span> [a] <span class="kw">where</span>
   insert <span class="fu">=</span> (<span class="fu">:</span>)
   member <span class="fu">=</span> undefined</code></pre></div>
<pre><code>-- (:) :: forall t. t -&gt; [t] -&gt; [t]
ColList :: forall a. ColDic a
ColList = \@ a -&gt; CD { insert = (:) @ a, member = undefined }</code></pre>
<h1 id="problem-with-muliparameter-type-classes-2">Problem with muliparameter type classes</h1>
<p><!--- `BadCollection2.hs` --> <!---
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE FlexibleInstances #-}
--></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Collection</span> c e <span class="kw">where</span>
<span class="ot">  empty ::</span> c
<span class="ot">  insert ::</span> e <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> c
<span class="ot">  member ::</span> e <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> <span class="dt">Bool</span>

<span class="kw">instance</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> <span class="dt">Collection</span> [a] a <span class="kw">where</span>
  empty <span class="fu">=</span> []
  insert  <span class="fu">=</span> (<span class="fu">:</span>)
  member <span class="fu">=</span> elem


ins2 x y c <span class="fu">=</span> insert y (insert x c)
<span class="co">-- ins2 :: (Collection c e, Collection c e1) =&gt; e1 -&gt; e -&gt; c -&gt; c</span>

<span class="ot">problem1 ::</span> [<span class="dt">Int</span>]
problem1 <span class="fu">=</span> ins2 <span class="dv">1</span> <span class="dv">2</span> []
<span class="co">-- No instances for (Collection [Int] e0, Collection [Int] e1)</span>
<span class="co">-- arising from a use of `ins2&#39;</span>

problem2 <span class="fu">=</span> ins2 <span class="ch">&#39;a&#39;</span> <span class="ch">&#39;b&#39;</span> []
<span class="co">-- No instance for (Collection [a0] Char)</span>
<span class="co">--       arising from a use of `ins2&#39;</span>

<span class="ot">problem3 ::</span> (<span class="dt">Collection</span> c0 <span class="dt">Char</span>, <span class="dt">Collection</span> c0 <span class="dt">Bool</span>) <span class="ot">=&gt;</span> c0 <span class="ot">-&gt;</span> c0
problem3 <span class="fu">=</span> ins2 <span class="dt">True</span> <span class="ch">&#39;a&#39;</span>
<span class="co">-- Here the problem is that this is type correct, but shouldn&#39;t</span></code></pre></div>
<h1 id="functional-dependencies">Functional dependencies</h1>
<p>Sometimes in multiparameter typeclasses, one parameter determines another, e.g.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"> <span class="kw">class</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">MonadState</span> s m <span class="fu">|</span> m <span class="ot">-&gt;</span> s <span class="kw">where</span> <span class="fu">...</span>

 <span class="kw">class</span> <span class="dt">Collects</span> e ce <span class="fu">|</span> ce <span class="ot">-&gt;</span> e <span class="kw">where</span>
<span class="ot">      empty  ::</span> ce
<span class="ot">      insert ::</span> e <span class="ot">-&gt;</span> ce <span class="ot">-&gt;</span> ce
<span class="ot">      member ::</span> e <span class="ot">-&gt;</span> ce <span class="ot">-&gt;</span> <span class="dt">Bool</span></code></pre></div>
<p>Exercise: verify that <code>Collects</code> solves the problem we had with <code>Collection</code></p>
<p>Problem: <em>Fundeps are very, very tricky.</em> - SPJ</p>
<p>More: https://www.microsoft.com/en-us/research/publication/understanding-functional-dependencies-via-constraint-handling-rules/</p>
<h1 id="reflection---why-not-constructor-classes">Reflection - why not constructor classes?</h1>
<p>We could try to solve the problem this way:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Collection</span> c <span class="kw">where</span>
<span class="ot">  insert ::</span> e <span class="ot">-&gt;</span> c e <span class="ot">-&gt;</span> c e
<span class="ot">  member ::</span> <span class="dt">Eq</span> e <span class="ot">=&gt;</span> e <span class="ot">-&gt;</span> c e<span class="ot">-&gt;</span> <span class="dt">Bool</span>

<span class="kw">instance</span> <span class="dt">Collection</span> [] <span class="kw">where</span>
     insert x xs <span class="fu">=</span> x<span class="fu">:</span>xs
     member <span class="fu">=</span> elem</code></pre></div>
<p>but this does not allow to solve the problem with the state monad:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"> <span class="kw">class</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">MonadState</span> s m <span class="fu">|</span> m <span class="ot">-&gt;</span> s <span class="kw">where</span>
<span class="ot">   get ::</span> m s
<span class="ot">   put ::</span> s <span class="ot">-&gt;</span> m ()</code></pre></div>
<p>the state type <code>s</code> is not a parameter of <code>m</code></p>
<h1 id="fundeps-are-very-very-tricky">Fundeps are very very tricky</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Mul</span> a b c <span class="fu">|</span> a b <span class="ot">-&gt;</span> c <span class="kw">where</span>
<span class="ot">  (*) ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c

<span class="kw">newtype</span> <span class="dt">Vec</span> a <span class="fu">=</span> <span class="dt">Vec</span> [a]
<span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Vec</span> <span class="kw">where</span>
  fmap f (<span class="dt">Vec</span> as) <span class="fu">=</span> <span class="dt">Vec</span> <span class="fu">$</span> map f as

<span class="kw">instance</span> <span class="dt">Mul</span> a b c <span class="ot">=&gt;</span> <span class="dt">Mul</span> a (<span class="dt">Vec</span> b) (<span class="dt">Vec</span> c) <span class="kw">where</span>
  a <span class="fu">*</span> b <span class="fu">=</span> fmap (a<span class="fu">*</span>) b

f t x y <span class="fu">=</span> <span class="kw">if</span> t <span class="kw">then</span>  x <span class="fu">*</span> (<span class="dt">Vec</span> [y]) <span class="kw">else</span> y</code></pre></div>
<p>What is the type of <code>f</code>? Let <code>x::a</code>, <code>y::b</code>.</p>
<p>Then the result type of <code>f</code> is <code>b</code> and we need an instance of <code>Mul a (Vec b) b</code></p>
<p>Now Z kolei <code>a b -&gt; c</code> implies <code>b ~ Vec c</code> for some <code>c</code>, so we are lookng for an instance</p>
<pre><code>Mul a (Vec (Vec c)) (Vec c)</code></pre>
<p>applying the rule <code>Mul a b c =&gt; Mul a (Vec b) (Vec c)</code> leads to <code>Mul a (Vec c) c</code>.</p>
<p>...and so on</p>
<h1 id="lets-try">Let's try</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">Mul1.hs<span class="fu">:</span><span class="dv">16</span><span class="fu">:</span><span class="dv">21</span><span class="fu">:</span>
    <span class="dt">Context</span> reduction stack overflow; size <span class="fu">=</span> <span class="dv">21</span>
    <span class="dt">Use</span> <span class="fu">-</span>fcontext<span class="fu">-</span>stack<span class="fu">=</span><span class="dt">N</span> to increase stack size to <span class="dt">N</span>
<span class="ot">      co ::</span> c18 <span class="fu">~</span> <span class="dt">Vec</span> c19
      <span class="fu">$</span><span class="ot">dMul ::</span> <span class="dt">Mul</span> a0 c17 c18
      <span class="fu">$</span><span class="ot">dMul ::</span> <span class="dt">Mul</span> a0 c16 c17
      <span class="fu">...</span>
      <span class="fu">$</span><span class="ot">dMul ::</span> <span class="dt">Mul</span> a0 c1 c2
      <span class="fu">$</span><span class="ot">dMul ::</span> <span class="dt">Mul</span> a0 c c1
      <span class="fu">$</span><span class="ot">dMul ::</span> <span class="dt">Mul</span> a0 c0 c
      <span class="fu">$</span><span class="ot">dMul ::</span> <span class="dt">Mul</span> a0 (<span class="dt">Vec</span> c0) c0
    <span class="dt">When</span> using functional dependencies to combine
      <span class="dt">Mul</span> a (<span class="dt">Vec</span> b) (<span class="dt">Vec</span> c),
        arising from the dependency <span class="ot">`a b -&gt; c&#39;</span>
<span class="ot">        in the instance declaration at 3/Mul1.hs:13:10</span>
<span class="ot">      Mul a0 (Vec c18) c18,</span>
<span class="ot">        arising from a use of `</span>mul&#39; at <span class="dv">3</span><span class="fu">/</span>Mul1.hs<span class="fu">:</span><span class="dv">16</span><span class="fu">:</span><span class="dv">21</span><span class="fu">-</span><span class="dv">23</span>
    <span class="dt">In</span> the expression<span class="fu">:</span> mul x (<span class="dt">Vec</span> [y])
    <span class="dt">In</span> the expression<span class="fu">:</span> <span class="kw">if</span> b <span class="kw">then</span> mul x (<span class="dt">Vec</span> [y]) <span class="kw">else</span> y</code></pre></div>
<p>(we need to use UndecidableInstances, to make GHC try - this example shows what is 'Undecidable').</p>
<h1 id="associated-types">Associated types</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE TypeFamilies #-}</span>
<span class="kw">class</span> <span class="dt">Collection</span> c <span class="kw">where</span>
      <span class="kw">type</span> <span class="dt">Elem</span><span class="ot"> c ::</span> <span class="fu">*</span>
<span class="ot">      empty ::</span> c
<span class="ot">      insert ::</span> <span class="dt">Elem</span> c <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> c
<span class="ot">      member ::</span> <span class="dt">Elem</span> c <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> <span class="dt">Bool</span>

<span class="kw">instance</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> <span class="dt">Collection</span> [a] <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">Elem</span> [a] <span class="fu">=</span> a
  empty <span class="fu">=</span> []
  insert  <span class="fu">=</span> (<span class="fu">:</span>)
  member <span class="fu">=</span> elem

<span class="ot">ins2 ::</span> <span class="dt">Collection</span> c <span class="ot">=&gt;</span> <span class="dt">Elem</span> c <span class="ot">-&gt;</span> <span class="dt">Elem</span> c <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> c
ins2 x y c <span class="fu">=</span> insert y (insert x c)

<span class="ot">noproblem1 ::</span> [<span class="dt">Int</span>]
noproblem1 <span class="fu">=</span> ins2 (<span class="dv">1</span><span class="ot">::</span><span class="dt">Int</span>) (<span class="dv">2</span><span class="ot">::</span><span class="dt">Int</span>) empty

<span class="ot">noproblem2 ::</span> [<span class="dt">Char</span>]
noproblem2 <span class="fu">=</span> ins2 <span class="ch">&#39;a&#39;</span> <span class="ch">&#39;b&#39;</span> empty</code></pre></div>
<h1 id="type-families">Type families</h1>
<p>Type families are functions on types</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# TypeFamilies #-}</span>

<span class="kw">data</span> <span class="dt">Zero</span> <span class="fu">=</span> <span class="dt">Zero</span>
<span class="kw">data</span> <span class="dt">Suc</span> n <span class="fu">=</span> <span class="dt">Suc</span> n

<span class="kw">type</span> family m <span class="fu">:+</span> n
<span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Zero</span> <span class="fu">:+</span> n <span class="fu">=</span> n
<span class="kw">type</span> <span class="kw">instance</span> (<span class="dt">Suc</span> m) <span class="fu">:+</span> n <span class="fu">=</span> <span class="dt">Suc</span>(m<span class="fu">:+</span>n)

<span class="ot">vhead ::</span> <span class="dt">Vec</span> (<span class="dt">Suc</span> n) a <span class="ot">-&gt;</span> a
<span class="ot">vappend ::</span> <span class="dt">Vec</span> m a <span class="ot">-&gt;</span> <span class="dt">Vec</span> n a <span class="ot">-&gt;</span> <span class="dt">Vec</span> (m<span class="fu">:+</span>n) a</code></pre></div>
<p>We'll talk about them systematically when we talk about dependent types in Haskell</p>
</body>
</html>
